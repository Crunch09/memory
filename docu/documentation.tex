% LaTeX Document for Android class @ THM
% \documentstyle[11pt]{article}
\documentclass[11pt,a4paper]{article}
\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{hyperref}
%\renewcommand{\ttdefault}{cmss}

\usepackage{lmodern}
\renewcommand{\familydefault}{\sfdefault}

%\newcommand{\changefont}[3]{
%\changefont{cmss}{m}{n} \changefont{cmss}{m}{sl} \changefont{cmss}{bx}{n} \selectfont}


% Default margins are too wide all the way around. I reset them here
\setlength{\topmargin}{-.5in}
\setlength{\textheight}{9in}
\setlength{\oddsidemargin}{.125in}
\setlength{\textwidth}{6.25in}
\begin{document}
\title{Memory - Dokumentation}
\author{A - Team\\Technische Hochschule Mittelhessen}
\renewcommand{\today}{11. September 2009}
\maketitle

\tableofcontents

\section {Prolog}
Die Gruppe A besteht aus Markus Kretsch, Frank Kevin Zey, Florian Thomas und Hagen Lauer.

\subsection{Anforderungen}

Muss
\begin{itemize}
\item Memory-Spielfeld mit sinnvoller Größe (z.B. 8x8 Karten/Felder) für 2 bis 6 Spieler.
\item Jeder Spieler bekommt einen Namen, der über Spielsitzungen hinweg gespeichert wird.
\item Über jeden Spieler wird eine Statistik angezeigt, wie z.B. Anzahl gewonnener \/ verlorener Spiele, oder Anzahl richtiger Treffer pro 100 Züge.
\end{itemize}
Kann
\begin{itemize}
\item Mehrspielermodus über mehrere Smartphones innerhalb eines LANs.
\item Weitere Spielkarten können z.B. von der SD-Karte nachinstalliert werden.
\end{itemize}
\subsection{Lösung / Idee}

\begin{itemize}

\item Bilder sollen mit Grid und Imageview dargestellt werden. Dabei bieten diese gute Möglichkeiten Klicks zu erkennen und entsprechend zu behandeln.
\item Für die Spieler wird eine SQLite Datenbank verwendet.
\item Wir haben gute Bibliotheken gefunden um die Daten der Spieler wie gewünscht statistisch auszuwerten und darzustellen.
\item Netzwerkspiele werden über WiFi und JavaSockets realisiert, dabei soll es einen Host und mehrere Clients pro Sitzung geben. Das Spielsystem muss also die entsprechende Flexibilität für lokale und Netzwerkspiele mitbringen.
\item Spielkarten sollen per .zip File von der SD Karte des Geräts nachladbar sein. Bilder werden in einer Datenbank gespeichert. Das Spiel lädt die Bilder für das Spielfeld aus der Datenbank.
\end{itemize}


%Type your text in free-format; lines can be as long
%or as short
%as you wish.
%      You can indent      or space out
%        your input 
%          text in 
%            any way you like to highlight the structure
%      of your manuscript and make it easier to edit.
%LaTeX fills lines and adjusts spacing between words to produce an
%aesthetically pleasing result.

%Completely blank lines in the input file break your text into
%paragraphs.
%To change the font for a single character, word, or set of words, 
%enclose the word and the font changing command within braces, 
%{\em like this}.
%A font changing command not enclosed in braces, like the change to \bf 
%bold here, keeps that change in effect until the end of the document or
%until countermanded by another font switch, like this change back to 
%\rm roman.

\section {Architektur}
Wir haben uns selbst als Ziel gesetzt, dass wir in 2 Richtungen entwickeln: Das Spiel Memory als sehr spezifische Implementierung und ein "'Framework"', das alle typischen Funktionen für ein rundenbasiertes Spiel mitbringt. So konnten wir mit entsprechenden Oberklassen (Game.java) und abgeleiteten Klassen (z.B. Memory.java) garantieren, dass am Ende beide Zweige zusammen führen.
Zum Framework gehört Game.java als Oberklasse aller implementierbaren rundenbasierten Spiele, eine Engine die im Wesentlichen Datenbankzugriffe kapselt, ein einfaches Menüsystem, das leicht konfigurier- und erweiterbar ist und einen statistischen Teil der mit der Datenbank zusammen arbeitet. Wir haben dann als Konkrete Implementierung für Memory die Klasse Memory.java von Game erben lassen und entsprechend für Memory angepasst. Ebenso wird die Netzwerkimplementierung eine von Game abgeleitete Klasse sein, natürlich noch mit einigen spezifischen Anpassungen zur Kommunikation der Geräte.

\subsection{Design}
Wie in \autoref{fig:memorydesign} zu sehen ist entsteht das Framework völlig unabhängig vom zu implementierenden Spiel.
\begin{figure}[!h]
\centering
\includegraphics[scale=0.4]{pics/memorydesign.png}
\caption{Konzept}
\label{fig:memorydesign}
\end{figure}

\subsection{Engine und Datenbank}
Die Engine umfasst die Typisierung der Spieler und Datenbankschnittstellen.
\subsubsection{Nachladen eines Kartendecks}
Beim Nachladen eines Kartendecks wird eine Zip File mit JPG Dateien erwartet. Diese Zip File muss eine JPG Datei mir Namen {\em 0.jpg} enthalten. Die Zip File wird aus der SD Karte geladen, dazu ist es zwingend notwendig, dass diese sich im root-Verzeichnis befindet.
Die Zip File wird von der Applikation geladen und entpackt. Während dem Entpacken werden die Informationen und einzelnen Bilder in einem deck Objekt gespeichert. Dabei kam es zu verschiedenen Problemen, einfachste Reader haben die jeweiligen Daten nicht aus dem Stream lesen können, somit wurde sich auf einen einfach InputStream geeinigt. Das ausgelesene Byte Array wurde anschliesend über eine BitmapFactory zu einem Bitmap Objekt dekodiert.\\
Wenn das Objekt vollständig erzeugt wurde, speichert es automatisch alle Daten in der Datenbank. Dabei kam es zu mehreren Problemen. Die Tabelle für ein Deck musste um eine weitere Tabelle in einer 1->n Beziehung ergänzt werden, nur so können alle Bilder mit Verweis auf das jeweilige Deck gespeichert werden.\\
Beim Laden der einzelnen Bilddaten kam es wegen den Streams wiedermal zu dem Problem, das ImageReader und ähnliche nicht wirkten, ein einfacher InputStream löst erneut das Problem.

\subsubsection{Allgemeines Datenbankdesign}
Die Datenbank umfasst 3 Tabellen. Diese Tabellen beinhalten die Informationen jedes einzelnen Spielers. Es wird der Nickname, die Siege, Niederlagen, sowie Unentschieden, getroffene Kartenpaare und die allgemeine durchgeführte Züge. Die jeweilige ID des Spielers entspricht dem jeweiligen Datensatz in der Datenbank.\\
Neben dem Spieler werden auch zusätzliche Kartendecks gespeichert. Da zu jedem Kartendeck es eine Rückseite vorhanden sein muss und 32 Vorderseiten, handelt es sich um eine 1 -$>$ n Beziehung. In der Datenbank werden zu jedem Kartendeck der Name gespeichert, dieser wird aus dem Dateinamen entnommen. Zusätzlich wird direkt die Rückseite in der Kartendeck Tabelle gespeichert, da die Rückseite nur einmal vorkommt und nicht noch aus der Kartentabelle gefiltert werden muss. Die Kartentabelle enthält die ID des jeweiligen Kartendecks als Referenz und einen Blob in dem die JPG Vorderseitenbilder als Byte Feld gespeichert wird.

Grösstes Problem während der Entwicklung des Datenbank Layouts waren immer wieder kleine Anpassungen durch ständige Weiterentwicklung der Software.

\subsection{Statistik}
crunch
\subsection{Memory}
Aufrgund des Aufbaues eines Memoryspieles bietet es sich an ein GridView zu verwenden. Zur Visualisierung der verschiedenen Karten in dem GridView haben wir uns für die ImageViews entschieden, weil sie einfach zu verstehen sind. \\

Die Bilder werden in der Klasse ``Theme`` aufbewart, welche diese aus der Datenbank liest, wenn es nicht das Default Theme ist. Dieses wird anhand von drawable Ressourcen geladen. Jedes Theme besteht aus einer Liste der Vorderseiten und einer Rückseite. \\

Das Memory lädt die ImageViews erstmal mit den Rückseiten in das GridView, weil man ja nicht sehen soll welche Karte sich darunter versteckt. Welches Bild sich wirklich unter dem Bild versteckt wird als id gespeichert. Wenn der User nun das erste Mal auf ein Bild klickt wird ein Zähler erhöht, um zu sehen ob das zweite Bilder gerade geklickt wird. Beim zweiten klick auf ein Bild  muss überprüft werden, ob es sich bei dem zweiten Bild

\begin{itemize}
	\item Um die selbe Position handelt 
	\item Ob sie die selbe id haben
\end{itemize}
	
Für den Fall das die die selbe Position haben, wird der Zähler wieder runtergezählt, für den Fall, dass die ids identisch sind, werden die ImageViews disabled und das Bild auf null gesetzt, sodass der Anwender sieht, dass das Bild weg ist. Ansonsten werden die Bilder wieder zurückgesetzt. \\

Hier entstand das Problem, dass die Bilder sofort verschwanden und der User nicht sehen konnte was den unter der 2. Karte liegt. Aus diesem Grund haben wir Threads erstellt, die eine gewisse Zeit warten und dann erst gegebene Aktionen durchführen, wie zum Beispiel das Reseten oder das Deleten zweier Karten. \\

Dies führte dann aber zu dem Problem, dass der User klicken konnte während die Karten, die vorher angeklickt wurden, noch zu sehen waren und somit einige Eigenarten hervorhohlen konnten. Desswegen haben wir für diesen Zeitraum die ImageView disabled damit dies nicht passiert.\\

Unser Memoryspiel ist in der Lage auf viele zeilen/reihen 
Kombinationen zu reagieren. Aufgrund der Feldgröße 8x8 sollte ein 
Theme 32 Karten + Rückseite haben haben.  \\
%Damit der Fall nicht auftritt, wo der User ein Theme importieren will mit weniger als 32 %Vorderseiten und der Rückseite, wird beim importieren überprüft, ob dies zutrifft, wenn nicht, %dann wird das Deck nicht importiert.

Um nun standartwerte benutzen/setzen zu können benutzen wir die Properties Klasse, welche einiges an Arbeit abnimmt. Die Konfigurationsdatei wird in dem lokalen Speicherbereich der Applikation gesichert. Um diesen herauszufinden benutzen wir die Funktion "getFilesDir()". \\

Diese wird beim Start ausgelesen, wenn nicht da oder unvollständig werden die Defaultwerte eingetragen, und bei den Settings gesetzt und auch geladen. \\

Beim laden des Memorys sind wir über den Fehler gestoßen, dass wir out of memory gegangen sind. Dies konnten wir beheben, indem wir in der Activity in der onDestroy methode die geladenen  Bitmaps wieder recyclen. \\

\subsection{Netzwerk}
crunch

\subsection*{Benutzerdokumentation}

Die Benutzerdokumentation wird per {\em Help} in der App bereitgestellt. 

\subsection*{API Dokumentation}

Die Code Dokumentation ist per JavaDoc im Quelltext abgewickelt.

\end{document}
