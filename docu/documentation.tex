% LaTeX Document for Android class @ THM
% \documentstyle[11pt]{article}
\documentclass[11pt,a4paper]{article}
\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{hyperref}
%\renewcommand{\ttdefault}{cmss}

\usepackage{lmodern}
\renewcommand{\familydefault}{\sfdefault}

%\newcommand{\changefont}[3]{
%\changefont{cmss}{m}{n} \changefont{cmss}{m}{sl} \changefont{cmss}{bx}{n} \selectfont}


% Default margins are too wide all the way around. I reset them here
\setlength{\topmargin}{-.5in}
\setlength{\textheight}{9in}
\setlength{\oddsidemargin}{.125in}
\setlength{\textwidth}{6.25in}
\begin{document}
\title{Memory - Dokumentation}
\author{A - Team\\Technische Hochschule Mittelhessen}
\renewcommand{\today}{11. September 2009}
\maketitle

\tableofcontents

\section {Prolog}
Die Gruppe A besteht aus Markus Kretsch, Frank Kevin Zey, Florian Thomas und Hagen Lauer.

\subsection{Anforderungen}

Muss
\begin{itemize}
\item Memory-Spielfeld mit sinnvoller GrÃ¶ÃŸe (z.B. 8x8 Karten/Felder) fÃ¼r 2 bis 6 Spieler.
\item Jeder Spieler bekommt einen Namen, der Ã¼ber Spielsitzungen hinweg gespeichert wird.
\item Ãœber jeden Spieler wird eine Statistik angezeigt, wie z.B. Anzahl gewonnener \/ verlorener Spiele, oder Anzahl richtiger Treffer pro 100 ZÃ¼ge.
\end{itemize}
Kann
\begin{itemize}
\item Mehrspielermodus Ã¼ber mehrere Smartphones innerhalb eines LANs.
\item Weitere Spielkarten kÃ¶nnen z.B. von der SD-Karte nachinstalliert werden.
\end{itemize}
\subsection{LÃ¶sung / Idee}

\begin{itemize}

\item Bilder sollen mit Grid und Imageview dargestellt werden. Dabei bieten diese gute MÃ¶glichkeiten Klicks zu erkennen und entsprechend zu behandeln.
\item FÃ¼r die Spieler wird eine SQLite Datenbank verwendet.
\item Wir haben gute Bibliotheken gefunden um die Daten der Spieler wie gewÃ¼nscht statistisch auszuwerten und darzustellen.
\item Netzwerkspiele werden Ã¼ber WiFi und JavaSockets realisiert, dabei soll es einen Host und mehrere Clients pro Sitzung geben. Das Spielsystem muss also die entsprechende FlexibilitÃ¤t fÃ¼r lokale und Netzwerkspiele mitbringen.
\item Spielkarten sollen per .zip File von der SD Karte des GerÃ¤ts nachladbar sein. Bilder werden in einer Datenbank gespeichert. Das Spiel lÃ¤dt die Bilder fÃ¼r das Spielfeld aus der Datenbank.
\end{itemize}


%Type your text in free-format; lines can be as long
%or as short
%as you wish.
%      You can indent      or space out
%        your input 
%          text in 
%            any way you like to highlight the structure
%      of your manuscript and make it easier to edit.
%LaTeX fills lines and adjusts spacing between words to produce an
%aesthetically pleasing result.

%Completely blank lines in the input file break your text into
%paragraphs.
%To change the font for a single character, word, or set of words, 
%enclose the word and the font changing command within braces, 
%{\em like this}.
%A font changing command not enclosed in braces, like the change to \bf 
%bold here, keeps that change in effect until the end of the document or
%until countermanded by another font switch, like this change back to 
%\rm roman.

\section {Architektur}
Wir haben uns selbst als Ziel gesetzt, dass wir in 2 Richtungen entwickeln: Das Spiel Memory als sehr spezifische Implementierung und ein "'Framework"', das alle typischen Funktionen fÃ¼r ein rundenbasiertes Spiel mitbringt. So konnten wir mit entsprechenden Oberklassen (Game.java) und abgeleiteten Klassen (z.B. Memory.java) garantieren, dass am Ende beide Zweige zusammen fÃ¼hren.
Zum Framework gehÃ¶rt Game.java als Oberklasse aller implementierbaren rundenbasierten Spiele, eine Engine die im Wesentlichen Datenbankzugriffe kapselt, ein einfaches MenÃ¼system, das leicht konfigurier- und erweiterbar ist und einen statistischen Teil der mit der Datenbank zusammen arbeitet. Wir haben dann als Konkrete Implementierung fÃ¼r Memory die Klasse Memory.java von Game erben lassen und entsprechend fÃ¼r Memory angepasst. Ebenso wird die Netzwerkimplementierung eine von Game abgeleitete Klasse sein, natÃ¼rlich noch mit einigen spezifischen Anpassungen zur Kommunikation der GerÃ¤te.

\subsection{Design}
Wie in \autoref{fig:memorydesign} zu sehen ist entsteht das Framework vÃ¶llig unabhÃ¤ngig vom zu implementierenden Spiel.
\begin{figure}[!h]
\centering
\includegraphics[scale=0.4]{pics/memorydesign.png}
\caption{Konzept}
\label{fig:memorydesign}
\end{figure}

\subsection{Engine und Datenbank}
Die Engine umfasst die Typisierung der Spieler und Datenbankschnittstellen.
\subsubsection{Spieler}
Der Spieler liegt als Klasse vor, mit allen Informationen, wie Nickname, Siege, Niederlagen, Unentschieden, getroffene Züge, sowie allgemein getätigte Züge und eine ID. Die ID entspricht der ID des entsprechenden Datensatzes in der Datenbank. Diese ID wird nach dem Speichern in der Datenbank im jeweiligen Objekt gespeichert.
\subsubsection{Nachladen eines Kartendecks}
Das Nachladen eines Kartendecks wird über eine SD Karte organisiert. Das neue Deck wird in einer Zip auf dieser SD Karte gespeichert. Diese Zip Datei kann unter Settings->Load Deck ausgewählt werden und dann wird es automatisch entpackt, in die Datenbank geschrieben und damit ist das Nachladen des Decks abgeschlossen.\\
Wichtig: Die Zip Datei muss im root-Verzeichnis der SD Karte zu finden sein. Ausserdem ist es wichtig, dass die Namensgebung der einzelnen JPG Dateien richtig gesetzt sind. Die Rückseite muss den Namen 0.jpg haben. Alle weiteren sind frei wählbar.
\subsubsection{Datenbank}
Die Datenbank umfasst 3 Tabellen. Diese Tabellen beinhalten die Informationen jedes einzelnen Spielers. Es wird der Nickname, die Siege, Niederlagen, sowie Unentschieden, getroffene Kartenpaare und die allgemeine durchgeführte Züge. Die jeweilige ID des Spielers entspricht dem jeweiligen Datensatz in der Datenbank.\\
Neben dem Spieler werden auch zusätzliche Kartendecks gespeichert. Da zu jedem Kartendeck es eine Rückseite vorhanden sein muss und 32 Vorderseiten, handelt es sich um eine 1 -> n Beziehung. In der Datenbank werden zu jedem Kartendeck der Name gespeichert, dieser wird aus dem Dateinamen entnommen. Zusätzlich wird direkt die Rückseite in der Kartendeck Tabelle gespeichert, da die Rückseite nur einmal vorkommt und nicht noch aus der Kartentabelle gefiltert werden muss. Die Kartentabelle enthält die ID des jeweiligen Kartendecks als Referenz und einen Blob in dem die JPG Vorderseitenbilder als Byte Feld gespeichert wird.
\subsection{Statistik}
crunch
\subsection{Memory}
markus
\subsection{Netzwerk}
crunch

\subsection*{Benutzerdokumentation}

Die Benutzerdokumentation wird per {\em Help} in der App bereitgestellt. 

\subsection*{API Dokumentation}

Die Code Dokumentation ist per JavaDoc im Quelltext abgewickelt.

\end{document}
