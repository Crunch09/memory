% LaTeX Document for Android class @ THM
% \documentstyle[11pt]{article}
\documentclass[11pt,a4paper]{article}
\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{hyperref}
%\renewcommand{\ttdefault}{cmss}

\usepackage{lmodern}
\renewcommand{\familydefault}{\sfdefault}

%\newcommand{\changefont}[3]{
%\changefont{cmss}{m}{n} \changefont{cmss}{m}{sl} \changefont{cmss}{bx}{n} \selectfont}


% Default margins are too wide all the way around. I reset them here
\setlength{\topmargin}{-.5in}
\setlength{\textheight}{9in}
\setlength{\oddsidemargin}{.125in}
\setlength{\textwidth}{6.25in}
\begin{document}
\title{Memory - Dokumentation}
\author{A - Team\\Technische Hochschule Mittelhessen}
\renewcommand{\today}{11. September 2009}
\maketitle

\tableofcontents

\section {Prolog}
Die Gruppe A besteht aus Markus Kretsch, Frank Kevin Zey, Florian Thomas und Hagen Lauer.

\subsection{Anforderungen}

Muss
\begin{itemize}
\item Memory-Spielfeld mit sinnvoller GrÃ¶ÃŸe (z.B. 8x8 Karten/Felder) fÃ¼r 2 bis 6 Spieler.
\item Jeder Spieler bekommt einen Namen, der Ã¼ber Spielsitzungen hinweg gespeichert wird.
\item Ãœber jeden Spieler wird eine Statistik angezeigt, wie z.B. Anzahl gewonnener \/ verlorener Spiele, oder Anzahl richtiger Treffer pro 100 ZÃ¼ge.
\end{itemize}
Kann
\begin{itemize}
\item Mehrspielermodus Ã¼ber mehrere Smartphones innerhalb eines LANs.
\item Weitere Spielkarten kÃ¶nnen z.B. von der SD-Karte nachinstalliert werden.
\end{itemize}
\subsection{LÃ¶sung / Idee}

\begin{itemize}

\item Bilder sollen mit Grid und Imageview dargestellt werden. Dabei bieten diese gute MÃ¶glichkeiten Klicks zu erkennen und entsprechend zu behandeln.
\item FÃ¼r die Spieler wird eine SQLite Datenbank verwendet.
\item Wir haben gute Bibliotheken gefunden um die Daten der Spieler wie gewÃ¼nscht statistisch auszuwerten und darzustellen.
\item Netzwerkspiele werden Ã¼ber WiFi und JavaSockets realisiert, dabei soll es einen Host und mehrere Clients pro Sitzung geben. Das Spielsystem muss also die entsprechende FlexibilitÃ¤t fÃ¼r lokale und Netzwerkspiele mitbringen.
\item Spielkarten sollen per .zip File von der SD Karte des GerÃ¤ts nachladbar sein. Bilder werden in einer Datenbank gespeichert. Das Spiel lÃ¤dt die Bilder fÃ¼r das Spielfeld aus der Datenbank.
\end{itemize}


%Type your text in free-format; lines can be as long
%or as short
%as you wish.
%      You can indent      or space out
%        your input 
%          text in 
%            any way you like to highlight the structure
%      of your manuscript and make it easier to edit.
%LaTeX fills lines and adjusts spacing between words to produce an
%aesthetically pleasing result.

%Completely blank lines in the input file break your text into
%paragraphs.
%To change the font for a single character, word, or set of words, 
%enclose the word and the font changing command within braces, 
%{\em like this}.
%A font changing command not enclosed in braces, like the change to \bf 
%bold here, keeps that change in effect until the end of the document or
%until countermanded by another font switch, like this change back to 
%\rm roman.

\section {Architektur}
Wir haben uns selbst als Ziel gesetzt, dass wir in 2 Richtungen entwickeln: Das Spiel Memory als sehr spezifische Implementierung und ein "'Framework"', das alle typischen Funktionen fÃ¼r ein rundenbasiertes Spiel mitbringt. So konnten wir mit entsprechenden Oberklassen (Game.java) und abgeleiteten Klassen (z.B. Memory.java) garantieren, dass am Ende beide Zweige zusammen fÃ¼hren.
Zum Framework gehÃ¶rt Game.java als Oberklasse aller implementierbaren rundenbasierten Spiele, eine Engine die im Wesentlichen Datenbankzugriffe kapselt, ein einfaches MenÃ¼system, das leicht konfigurier- und erweiterbar ist und einen statistischen Teil der mit der Datenbank zusammen arbeitet. Wir haben dann als Konkrete Implementierung fÃ¼r Memory die Klasse Memory.java von Game erben lassen und entsprechend fÃ¼r Memory angepasst. Ebenso wird die Netzwerkimplementierung eine von Game abgeleitete Klasse sein, natÃ¼rlich noch mit einigen spezifischen Anpassungen zur Kommunikation der GerÃ¤te.

\subsection{Design}
Wie in \autoref{fig:memorydesign} zu sehen ist entsteht das Framework vÃ¶llig unabhÃ¤ngig vom zu implementierenden Spiel.
\begin{figure}[!h]
\centering
\includegraphics[scale=0.4]{pics/memorydesign.png}
\caption{Konzept}
\label{fig:memorydesign}
\end{figure}

\subsection{Engine und Datenbank}
Die Engine umfasst die Typisierung der Spieler und Datenbankschnittstellen.
\subsubsection{Nachladen eines Kartendecks}
Beim Nachladen eines Kartendecks wird eine Zip File mit JPG Dateien erwartet. Diese Zip File muss eine JPG Datei mir Namen {\em 0.jpg} enthalten. Die Zip File wird aus der SD Karte geladen, dazu ist es zwingend notwendig, dass diese sich im root-Verzeichnis befindet.
Die Zip File wird von der Applikation geladen und entpackt. Während dem Entpacken werden die Informationen und einzelnen Bilder in einem deck Objekt gespeichert. Dabei kam es zu verschiedenen Problemen, einfachste Reader haben die jeweiligen Daten nicht aus dem Stream lesen können, somit wurde sich auf einen einfach InputStream geeinigt. Das ausgelesene Byte Array wurde anschliesend über eine BitmapFactory zu einem Bitmap Objekt dekodiert.\\
Wenn das Objekt vollständig erzeugt wurde, speichert es automatisch alle Daten in der Datenbank. Dabei kam es zu mehreren Problemen. Die Tabelle für ein Deck musste um eine weitere Tabelle in einer 1->n Beziehung ergänzt werden, nur so können alle Bilder mit Verweis auf das jeweilige Deck gespeichert werden.\\
Beim Laden der einzelnen Bilddaten kam es wegen den Streams wiedermal zu dem Problem, das ImageReader und ähnliche nicht wirkten, ein einfacher InputStream löst erneut das Problem.

\subsubsection{Allgemeines Datenbankdesign}
Die Datenbank umfasst 3 Tabellen. Diese Tabellen beinhalten die Informationen jedes einzelnen Spielers. Es wird der Nickname, die Siege, Niederlagen, sowie Unentschieden, getroffene Kartenpaare und die allgemeine durchgeführte Züge. Die jeweilige ID des Spielers entspricht dem jeweiligen Datensatz in der Datenbank.\\
Neben dem Spieler werden auch zusätzliche Kartendecks gespeichert. Da zu jedem Kartendeck es eine Rückseite vorhanden sein muss und 32 Vorderseiten, handelt es sich um eine 1 -> n Beziehung. In der Datenbank werden zu jedem Kartendeck der Name gespeichert, dieser wird aus dem Dateinamen entnommen. Zusätzlich wird direkt die Rückseite in der Kartendeck Tabelle gespeichert, da die Rückseite nur einmal vorkommt und nicht noch aus der Kartentabelle gefiltert werden muss. Die Kartentabelle enthält die ID des jeweiligen Kartendecks als Referenz und einen Blob in dem die JPG Vorderseitenbilder als Byte Feld gespeichert wird.

Grösstes Problem während der Entwicklung des Datenbank Layouts waren immer wieder kleine Anpassungen durch ständige Weiterentwicklung der Software.

\subsection{Statistik}
crunch
\subsection{Memory}
markus
\subsection{Netzwerk}
crunch

\subsection*{Benutzerdokumentation}

Die Benutzerdokumentation wird per {\em Help} in der App bereitgestellt. 

\subsection*{API Dokumentation}

Die Code Dokumentation ist per JavaDoc im Quelltext abgewickelt.

\end{document}